"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneSequenceEventQueueProcessor = void 0;
const tiny_types_1 = require("tiny-types");
const events_1 = require("@serenity-js/core/lib/events");
const EventQueueProcessor_1 = require("../EventQueueProcessor");
const transformations_1 = require("../transformations");
const SceneSequenceReportContext_1 = require("./SceneSequenceReportContext");
const transformations_2 = require("./transformations");
const scenarioParameterResult_1 = require("./transformations/scenarioParameterResult");
const scenarioParametersOf_1 = require("./transformations/scenarioParametersOf");
/**
 * @package
 */
class SceneSequenceEventQueueProcessor extends EventQueueProcessor_1.EventQueueProcessor {
    supports(queue) {
        return queue
            && queue.first() instanceof events_1.SceneSequenceDetected;
    }
    process(queue) {
        return queue.reduce((context, event) => tiny_types_1.match(event)
            .when(events_1.SceneSequenceDetected, this.onSceneSequenceDetected(context))
            .when(events_1.SceneStarts, this.onSceneStarts(context))
            .when(events_1.SceneTemplateDetected, this.onSceneTemplateDetected(context))
            .when(events_1.SceneParametersDetected, this.onSceneParametersDetected(context))
            .when(events_1.FeatureNarrativeDetected, this.onFeatureNarrativeDetected(context))
            .when(events_1.SceneBackgroundDetected, this.onSceneBackgroundDetected(context))
            .when(events_1.SceneDescriptionDetected, this.onSceneDescriptionDetected(context))
            .when(events_1.BusinessRuleDetected, this.onBusinessRuleDetected(context))
            .when(events_1.TestRunnerDetected, this.onTestRunnerDetected(context))
            .when(events_1.SceneTagged, this.onSceneTagged(context))
            .when(events_1.ActivityStarts, this.onActivityStarts(context))
            .when(events_1.ActivityFinished, this.onActivityFinished(context))
            .when(events_1.ActivityRelatedArtifactGenerated, this.onActivityRelatedArtifactGenerated(context))
            .when(events_1.ActivityRelatedArtifactArchived, this.onActivityRelatedArtifactArchived(context))
            .when(events_1.SceneFinished, this.onSceneFinished(context))
            .else(() => context), new SceneSequenceReportContext_1.SceneSequenceReportContext()).build();
    }
    onSceneSequenceDetected(context) {
        return (event) => context
            .with(transformations_1.reportIdIncluding(event.details.category.value, event.details.name.value))
            .with(transformations_1.scenarioDetailsOf(event.details));
    }
    onSceneStarts(context) {
        return (event) => context
            .with(transformations_1.activityStarted(event.sceneId, event.details.name, event.timestamp))
            .with(transformations_1.executionStartedAt(event.timestamp));
    }
    onSceneTemplateDetected(context) {
        return (event) => context
            .with(transformations_2.scenarioOutlineOf(event.template));
    }
    onSceneParametersDetected(context) {
        return (event) => context
            .with(scenarioParametersOf_1.scenarioParametersOf(event.details, event.parameters));
    }
    onActivityStarts(context) {
        return (event) => context
            .with(transformations_1.activityStarted(event.activityId, event.details.name, event.timestamp));
    }
    onActivityFinished(context) {
        return (event) => context
            .with(transformations_1.activityFinished(event.activityId, event.outcome, event.timestamp));
    }
    onSceneFinished(context) {
        return (event) => context
            .with(transformations_1.activityFinished(event.sceneId, event.outcome, event.timestamp))
            .with(scenarioParameterResult_1.scenarioParameterResult(event.details, event.outcome))
            .with(transformations_2.sceneSequenceOverallResult(event.outcome))
            .with(transformations_1.executionFinishedAt(event.timestamp));
    }
}
exports.SceneSequenceEventQueueProcessor = SceneSequenceEventQueueProcessor;
//# sourceMappingURL=SceneSequenceEventQueueProcessor.js.map