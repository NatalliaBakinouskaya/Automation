"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tagOf = void 0;
const model_1 = require("@serenity-js/core/lib/model");
const tiny_types_1 = require("tiny-types");
const objects_1 = require("tiny-types/lib/objects"); // tslint:disable-line:no-submodule-imports
const reportIdIncluding_1 = require("./reportIdIncluding");
/**
 * @package
 */
function tagOf(tag) {
    return (context) => tiny_types_1.match(tag)
        .when(model_1.ManualTag, _ => {
        context.report.manual = true;
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(tag));
        return context;
    })
        .when(model_1.ThemeTag, _ => {
        const themeTag = {
            ...tagReportFor(tag),
            displayName: tag.name,
        };
        context.report.tags = concatIfNotPresent(context.report.tags, themeTag);
        return context;
    })
        .when(model_1.CapabilityTag, _ => {
        const capabilityTag = {
            ...tagReportFor(tag),
            name: join('/', displayNameOfRecorded(model_1.ThemeTag, context.report.tags), tag.name),
            displayName: tag.name,
        };
        context.report.tags = concatIfNotPresent(context.report.tags, capabilityTag);
        return context;
    })
        .when(model_1.FeatureTag, _ => {
        const featureTag = {
            ...tagReportFor(tag),
            name: join('/', displayNameOfRecorded(model_1.CapabilityTag, context.report.tags), tag.name),
            displayName: tag.name,
        };
        context.report.featureTag = featureTag;
        context.report.tags = concatIfNotPresent(context.report.tags, featureTag);
        return context;
    })
        .when(model_1.IssueTag, _ => {
        context.report.issues = concatIfNotPresent(context.report.issues, tag.name);
        context.report.additionalIssues = concatIfNotPresent(context.report.additionalIssues, tag.name);
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(tag));
        return context;
    })
        .when(model_1.BrowserTag, (browserTag) => {
        reportIdIncluding_1.reportIdIncluding(browserTag.name)(context);
        context.report.context = appendIfNotPresent(context.report.context, browserTag.browserName);
        context.report.driver = browserTag.browserName;
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(browserTag));
        return context;
    })
        .when(model_1.PlatformTag, _ => {
        reportIdIncluding_1.reportIdIncluding(tag.name)(context);
        context.report.context = appendIfNotPresent(context.report.context, tag.name);
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(tag));
        return context;
    })
        .when(model_1.ContextTag, _ => {
        reportIdIncluding_1.reportIdIncluding(tag.name)(context);
        context.report.context = tag.name;
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(tag));
        return context;
    })
        .when(model_1.ExecutionRetriedTag, _ => {
        reportIdIncluding_1.reportIdIncluding(tag.name)(context);
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(tag));
        return context;
    })
        .else(_ => {
        context.report.tags = concatIfNotPresent(context.report.tags, tagReportFor(tag));
        return context;
    });
}
exports.tagOf = tagOf;
function concatIfNotPresent(items, item) {
    const currentTags = items || [];
    return !!currentTags.find(current => objects_1.equal(current, item))
        ? currentTags
        : currentTags.concat(item);
}
function appendIfNotPresent(commaSeparatedStringOrEmpty, item) {
    return unique((commaSeparatedStringOrEmpty || '')
        .split(',')
        .filter(_ => !!_)
        .concat(item)).join(',');
}
function tagReportFor(tag) {
    return {
        ...tag.toJSON(),
        displayName: tag.name.replace(/_+/, ' '),
    };
}
function join(separator, ...values) {
    return values.filter(_ => !!_).join(separator);
}
function unique(items) {
    return [...new Set(items)];
}
function displayNameOfRecorded(typeOfTag, tags) {
    const found = (tags || []).find(t => t.type === typeOfTag.Type);
    return found && found.displayName;
}
//# sourceMappingURL=tagOf.js.map